# Exploratory suite:
# (A) Harmonic power ratios for the three carriers (fundamental + harmonics up to Nyquist).
# (B) Real cepstrum of log-spectrum to detect quefrency peaks near periods ~3,4,2.15.
# (C) Cumulative growth: power at carrier bins vs N for N=250..2000.
#
# Outputs: CSVs + PNGs in /mnt/data for download.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
from collections import Counter
from typing import List, Tuple

# ---------- Core AMFT computation ----------
def remove_factors(n: int, b: int) -> int:
    if b <= 1:
        return n
    x = b
    p = 2
    while p * p <= x:
        while x % p == 0:
            while n % p == 0:
                n //= p
            x //= p
        p += 1 if p == 2 else 2
    if x > 1:
        while n % x == 0:
            n //= x
    return n

def multiplicative_order(b: int, m: int, max_steps: int = 200000) -> int:
    if m <= 1 or math.gcd(b, m) != 1:
        return 0
    val = 1
    for k in range(1, max_steps+1):
        val = (val * b) % m
        if val == 1:
            return k
    return 0

def repetend_digits(numerator: int, denominator: int, base: int, max_len: int = 20000) -> List[int]:
    if denominator == 0:
        return []
    rem_pos = {}
    digits = []
    rem = numerator % denominator
    pos = 0
    while rem != 0 and rem not in rem_pos and pos < max_len:
        rem_pos[rem] = pos
        rem *= base
        digit = rem // denominator
        digits.append(int(digit))
        rem = rem % denominator
        pos += 1
    if rem == 0 or pos >= max_len:
        return []
    start = rem_pos[rem]
    return digits[start:]

def shannon_entropy(digs: List[int], base: int) -> float:
    if not digs:
        return 0.0
    cnt = Counter(digs)
    N = len(digs)
    ent = 0.0
    for c in cnt.values():
        p = c / N
        if p > 0.0:
            ent -= p * (math.log(p) / math.log(base))
    return ent

def compute_M_T(T_max: int, bases: Tuple[int,...], numerator: int) -> np.ndarray:
    M_vals = np.zeros(T_max, dtype=float)
    for T in range(1, T_max+1):
        m = 5*T + 1
        M_sum = 0.0
        for b in bases:
            mprime = remove_factors(m, b)
            Lb = multiplicative_order(b, mprime)
            H = 0.0
            if Lb > 0:
                rep = repetend_digits(numerator, m, b)
                H = shannon_entropy(rep, b)
            M_sum += Lb * H
        M_vals[T-1] = M_sum / len(bases)
    return M_vals

def fft_pos_power(x: np.ndarray):
    x = x - x.mean()
    X = np.fft.fft(x)
    f = np.fft.fftfreq(len(x), d=1.0)
    mask = f > 0
    return f[mask], np.abs(X[mask])**2

# ---------- Baseline ----------
Tmax = 2000
bases = (2,3,5,7,10)
numerator = 6
M = compute_M_T(Tmax, bases, numerator)
freqs, power = fft_pos_power(M)
df_spec = pd.DataFrame({"freq": freqs, "period": 1.0/freqs, "power": power})
df_spec.to_csv("/mnt/data/explore_baseline_spectrum_T2000.csv", index=False)

# ---------- (A) Harmonic power ratios ----------
carriers = {"P3": 1/3.0, "P4": 1/4.0, "P2_15": 1/2.15}
bin_width = 1.0 / Tmax
tol = 1.5 * bin_width

records = []
for name, f0 in carriers.items():
    kmax = int(np.floor(0.5 / f0))
    for k in range(1, kmax+1):
        fh = k * f0
        idx = int(np.argmin(np.abs(freqs - fh)))
        # local background: median of a window excluding the central 2 bins
        win = 10  # bins on each side
        lo = max(0, idx - win)
        hi = min(len(power)-1, idx + win)
        neigh = np.r_[power[lo:idx-1], power[idx+2:hi+1]] if idx-1>lo and hi>idx+2 else power[lo:hi+1]
        bg_med = float(np.median(neigh)) if len(neigh)>0 else np.nan
        pval = float(power[idx])
        snr = pval / bg_med if bg_med and bg_med>0 else np.nan
        records.append({
            "carrier": name,
            "k": k,
            "harmonic_freq": float(freqs[idx]),
            "harmonic_period": float(1.0/freqs[idx]),
            "power": pval,
            "local_bg_median": bg_med,
            "power_over_bg": snr
        })

df_harm = pd.DataFrame(records)
df_harm.to_csv("/mnt/data/harmonic_power_ratios_T2000.csv", index=False)

# Plot: power/background vs harmonic index
for name in carriers.keys():
    sub = df_harm[df_harm["carrier"]==name].copy()
    plt.figure(figsize=(8,4))
    plt.plot(sub["k"], sub["power_over_bg"], marker="o")
    plt.yscale("log")
    plt.xlabel("Harmonic index k")
    plt.ylabel("Power / local background (log)")
    plt.title(f"Harmonic strength for {name} (T=2000)")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f"/mnt/data/harmonic_strength_{name}_T2000.png", dpi=170, bbox_inches="tight")
    plt.close()

# ---------- (B) Cepstrum ----------
# real cepstrum of log-magnitude spectrum
eps = 1e-12
log_spec = np.log(np.abs(np.fft.fft(M - M.mean())) + eps)
cep = np.real(np.fft.ifft(log_spec))
# quefrency axis in "shells"
q = np.arange(len(cep))
# Only show low-quefrency region where periodicities live; up to, say, 50 shells
qmax = 60
plt.figure(figsize=(10,4))
plt.plot(q[:qmax], cep[:qmax])
for P in [3.0, 4.0, 2.15]:
    plt.axvline(P, linestyle="--")
plt.xlabel("Quefrency (shells)")
plt.ylabel("Real cepstrum")
plt.title("Real cepstrum of M(T) (log-spectrum)")
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig("/mnt/data/cepstrum_T2000.png", dpi=170, bbox_inches="tight")
plt.close()

# Save a CSV with the sampled cepstrum (first 200 quefrencies)
pd.DataFrame({"quefrency_shells": q[:200], "cepstrum": cep[:200]}).to_csv("/mnt/data/cepstrum_T2000.csv", index=False)

# ---------- (C) Cumulative growth ----------
Ns = np.arange(250, Tmax+1, 50)
rows = []
for N in Ns:
    fN, pN = fft_pos_power(M[:N])
    for label, f0 in carriers.items():
        idx = int(np.argmin(np.abs(fN - f0)))
        rows.append({"N": N, "carrier": label, "freq_bin": fN[idx], "power": pN[idx]})
df_growth = pd.DataFrame(rows)
df_growth.to_csv("/mnt/data/cumulative_growth_T2000.csv", index=False)

# Plot growth curves
plt.figure(figsize=(9,5))
for label in carriers.keys():
    sub = df_growth[df_growth["carrier"]==label]
    plt.plot(sub["N"], sub["power"], label=label)
plt.yscale("log")
plt.xlabel("N (first N shells)")
plt.ylabel("Power at carrier bin (log)")
plt.title("Cumulative power growth at carrier bins")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig("/mnt/data/cumulative_growth_T2000.png", dpi=170, bbox_inches="tight")
plt.close()

(
 "/mnt/data/harmonic_power_ratios_T2000.csv",
 "/mnt/data/harmonic_strength_P3_T2000.png",
 "/mnt/data/harmonic_strength_P4_T2000.png",
 "/mnt/data/harmonic_strength_P2_15_T2000.png",
 "/mnt/data/cepstrum_T2000.png",
 "/mnt/data/cepstrum_T2000.csv",
 "/mnt/data/cumulative_growth_T2000.png",
 "/mnt/data/cumulative_growth_T2000.csv"
)
